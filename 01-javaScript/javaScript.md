<!--
 * @Author: shengCW
 * @Email: 2367896538@qq.com
 * @Date: 2021-02-19 11:03:18
 * @LastEditors: shengCW
 * @LastEmail: 2367896538@qq.com
 * @LastEditTime: 2021-02-22 13:26:21
 * @Description: file content
-->

<!-- TOC -->

- [1. js数据类型](#1-js数据类型)
- [2. 基本数据类型与引用数据类型的区别？](#2-基本数据类型与引用数据类型的区别)
- [3. null 和 undefined 的区别](#3-null-和-undefined-的区别)
- [4. 数据类型相互转换规则](#4-数据类型相互转换规则)
  - [4.1. 其他类型转换成String](#41-其他类型转换成string)
  - [4.2. 其他类型转换成Number](#42-其他类型转换成number)
  - [4.3. 其他类型转换成Boolean](#43-其他类型转换成boolean)
- [5. 什么情况下会发生布尔值的隐式强制类型转换](#5-什么情况下会发生布尔值的隐式强制类型转换)
- [6. == 操作符的强制类型转换规则](#6--操作符的强制类型转换规则)
- [7. 如何将字符串转化为数字，例如 '12.3b'](#7-如何将字符串转化为数字例如-123b)
- [8. || 和 && 操作符的返回值](#8--和--操作符的返回值)
- [9. typeof能否正确判断数据类型？instanceof 能判断对象的原理是什么](#9-typeof能否正确判断数据类型instanceof-能判断对象的原理是什么)
- [10. 手写instanceof](#10-手写instanceof)
- [11. 理解原型链](#11-理解原型链)
- [12. javaScript 继承的几种实现方式](#12-javascript-继承的几种实现方式)
- [13. js 遍历对象和遍历数组的方式](#13-js-遍历对象和遍历数组的方式)
  - [13.1. 遍历对象](#131-遍历对象)
  - [13.2. 遍历数组](#132-遍历数组)
- [14. valueOf 和 toString 的区别](#14-valueof-和-tostring-的区别)
- [15. {} 和 [] 的 valueOf 和 toString 的结果是什么](#15--和--的-valueof-和-tostring-的结果是什么)
- [16. eval 是做什么的](#16-eval-是做什么的)
- [17. 事件对象中的clientX offsetX screenX pageX的区别](#17-事件对象中的clientx-offsetx-screenx-pagex的区别)
- [18. 三种事件模型是什么](#18-三种事件模型是什么)
- [19. 如何阻止事件冒泡](#19-如何阻止事件冒泡)
- [20. 如何阻止事件默认行为](#20-如何阻止事件默认行为)
- [21. 事件代理/事件委托 以及 优缺点](#21-事件代理事件委托-以及-优缺点)

<!-- /TOC -->
## 1. js数据类型

js 分两种数据类型：
  6种基本数据类型：`Number`、 `Boolean`、 `String`、 `undefined`、 `null`、 `Symbol` 其中 `Symbol` 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。
  
  引用数据类型：`Object`(在JS中除了基本数据类型以外的都是对象)

## 2. 基本数据类型与引用数据类型的区别？

- 声明变量时内存分配不同
  - 基本数据类型保存在栈中，引用数据类型保存在堆中
- 不同的内存分配带来不同的访问机制
  - 在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。
- 复制变量时的不同
  - 基本数据类型：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。
  - 引用数据类型：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。
- 参数传递的不同（把实参复制给形参的过程）
首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。
  - 基本数据类型：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
  - 引用数据类型：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。
  
## 3. null 和 undefined 的区别

- 两者都是基本数据类型，分别都只有一个值，就是`undefined`和`null`
- `undefined`代表的含义是未定义，`null`代表的含义是空对象，变量声明未赋值和函数没有返回值时会返回`undefined`, `null`主要用于赋值给可能会返回对象的变量，作为初始化。
- 使用`typeof`进行判断时，`undefined`会返回"undefined",`null`会返回"object",这是历史遗留问题。
- 两者使用`==`相等比较返回true，使用`===`全等比较返回false
- `undefined`在`js`中不是一个保留字。这意味着可以使用`undefined`来作为一个变量名，这种做法非常危险，他会影响我们对`undefined`的判断

## 4. 数据类型相互转换规则

### 4.1. 其他类型转换成String

- `null`和`undefined`类型：`null`转换成"null"，`undefined`转换为"undefined"
- `Number`类型：直接转换，不过极小极大的数字会使用指数形式
- `Boolean`类型：`true`转换为"true", `false`转换为"false"
- `Symbol`类型：直接转换，只允许显式强制类型转换，使用隐式类型转换会产生错误
- 对普通对象来说，除非自行定义`toString()`方法，否则会调用toString()（Object.prototype.toString()）来返回内部属性[[Class]]的值，如"[Object Object]"。如果对象有自己的toString()方法，字符串化时就会调用该方法并使用其返回值。

### 4.2. 其他类型转换成Number

- `null`和`undefined`类型：`null`转换成0，`undefined`转换为`NaN`
- `String` 类型: 如果使用 Number() 函数进行转换，如果包含非数字值则转换为`NaN`，空字符串为 0。
- `Boolean`类型：`true`转换为1, `false`转换为0
- `Symbol`类型：不能转换为数字，会报错
- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

```shell
为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。
如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。
如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
```

### 4.3. 其他类型转换成Boolean

假值：`undefined`、`null`、`false`、`+0`、`-0`、`NaN`、`""`

假值转换结果为`false`,假值以为的都应该是真值

## 5. 什么情况下会发生布尔值的隐式强制类型转换

## 6. == 操作符的强制类型转换规则

## 7. 如何将字符串转化为数字，例如 '12.3b'

## 8. || 和 && 操作符的返回值

## 9. typeof能否正确判断数据类型？instanceof 能判断对象的原理是什么

- typeof 对于基本数据类型来说，除了null都可以显示正确的类型，typeof null 返回一个'object'，所以typeof 并不能准确判断变量到底是什么类型
- typeof 对于引用类型来说，除了函数都会显示object,typeof console.log 返回一个'function'，instanceof可以正确判断一个数的数据类型，因为内部机制是通过原型链来判断的

## 10. 手写instanceof

```javascript
 function myInstanceof(left, right) {
    // 获取的类型的原型
    let prototype = right.prototype;
    // 获取对象的原型
    let obj = left.__proto__;
    // 判断对象的类型是否等于类型的原型
    while(true) {
      if(obj === null) return false;
      if(obj === prototype) return true;
      obj = obj.__proto__;
    }
  }
```

## 11. 理解原型链

理解原型链首先理解这张图：

![prototype](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3842555d9aef47af98102f763b2b88ff~tplv-k3u1fbpfcp-watermark.image)

首先理解：构造函数，原型对象，实例对象之间的关系

- 对象都有一个`__proto__`属性
- 构造函数才有原型对象`prototype`
- 实例对象`f1`是通过构造函数`Foo()` `new`出来的，实例对象有一个`__proto__`属性，指向构造函数的原型对象，即`f1.__proto__ === Foo.prototype`
- `prototype`本身也是一个对象，它也有`__proto__`,依次向上找会找到`Object.prototype`, `Object.prototype`在向上找就是`null`了，按此查找形成的链条就是原型链
- 原型对象有一个`constructor`指向构造函数本人，构造函数也是对象，同样也就用`__proto__`指向`Function.prototype`
- `__proto__`先指向构造函数的原型对象，最后再指向`Object.prototype`

## 12. javaScript 继承的几种实现方式

- 原型链继承：有一定的缺点：原型中包含的引用值会在所有的实例间共享，容易造成修改修改混乱。还有子类型在实例化时不能给父类型的构造函数传参。
- 借用构造函数继承：借用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。借用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能借用构造函数模式。
- 组合继承：综合了原型链和借用构造函数，基本思路是使用原型链继承原型上的属性和方法，而借用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。由于我们是以父类的实例作为子类的原型，又在子类构造函数中调用父类，所以调用了两次父类构造函数，造成了子类原型中多了很多不必要的属性
- 原型式继承：原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。
- 寄生式继承：寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。
- 寄生式组合继承：组合继承的缺点就是使用父类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用父类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## 13. js 遍历对象和遍历数组的方式

### 13.1. 遍历对象

- for...in 循环遍历对象自身的和继承的可枚举属性（不包含Symbol属性）
- Object.keys() 返回一个数组，包括对象自身的（不含继承的）所有可枚举的属性（不包含Symbol属性）
- Object.getOwnPropertyNames() 返回一个数组，包含对象自身的所有属性（不包含Symbol属性，但是包括不可枚举属性）
- Reflect.ownKeys() 返回一个数组，包含对象自身的所有属性（包括Symbol属性和不可枚举属性）

### 13.2. 遍历数组

- forEach()
- for...in 遍历的是索引
- for...of

## 14. valueOf 和 toString 的区别

<https://juejin.cn/post/6873215243804213262>

## 15. {} 和 [] 的 valueOf 和 toString 的结果是什么

## 16. eval 是做什么的

## 17. 事件对象中的clientX offsetX screenX pageX的区别

## 18. 三种事件模型是什么

## 19. 如何阻止事件冒泡

## 20. 如何阻止事件默认行为

## 21. 事件代理/事件委托 以及 优缺点
